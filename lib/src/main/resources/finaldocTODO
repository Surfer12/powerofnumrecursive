```
CIS 233 - 01
Fall 2024
Assignment 2
Author:
Description: This program calculates the power of a number using recursion.
```
```java
public class PowerOfNum {
    public double power(int x, int n) {
        if (n < 0) {
            System.err.println("Negative exponent not allowed: " + n + ". Input a valid number that is greater than or equal to 0");
            return -1;
        }
        if (n == 0) {
            return 1.0;
        }
        
        double halfPower = power(x, n / 2);
        if (n % 2 == 0) {
            return (halfPower * halfPower);
        } else {
            return (x * (halfPower * halfPower));
        }
    }
}
```

Flow: Class PowerOfNum
Recursive Method: power(num, exp)
Description of recursive method:
   - User calls `power(num, exp)` (num = base, exp = exponent) ; (Both are integers that are non-negative and stored in variables that serve as auxilliary space placeholders for this power method)
   - If `exp < 0`: 
     - Print error message 
     - Return -1 (error code)
   - If `exp == 0`:
     - Return `1.0` (base case) 
   - Calculate single halfPower value = power(num, exp/2)
   - If `exp % 2 == 0`:
     - Return `halfPower * halfPower` (recursive case) ; (This resolves to the base case when exp is even and the recursion will be a step away from completing)
   - Else:
     - Return `num * halfPower * halfPower` (recursive case) ; (This resolves to the base case when exp is odd and the recursion will be a step away from completing)
```
Flow: Numerical Example

Example: power(2, 5)

power(2, 5):
- n = 5 (odd)
- halfPower = power(2, 5/2) = power(2, 2)  // integer division gives 2
- returns 2 * halfPower * halfPower        // this gives us 2 * (2^2) * (2^2) = 2 * 4 * 4 = 32

power(2, 2):
- n = 2 (even)
- halfPower = power(2, 1)
- returns halfPower * halfPower            // this gives us 2 * 2 = 4

power(2, 1):
- n = 1 (odd)
- halfPower = power(2, 0)                  // integer division of 1/2 = 0
- returns 2 * halfPower * halfPower        // this gives us 2 * 1 * 1 = 2

power(2, 0):
- returns 1.0
```
```markdown
### Context of recursion: "Going back up the call stack"
#### Explanation of the Call Stack in Recursion
1. Recursive Calls:
When a function calls itself, it creates a new layer in the call stack. 
Each call has its own set of parameters and local variables.

Let’s illustrate this with the example of power(2, 5):
Call Stack Creation:

/* Recursive Call Stack Analysis for power(x, n):

Example: power(2, 5)
Call Stack Formation (Going Down):
1. power(2, 5)
   - n is odd, will need: 2 * (halfPower * halfPower)
   - calls power(2, 2)
   
2. power(2, 2)
   - n is even, will need: halfPower * halfPower
   - calls power(2, 1)
   
3. power(2, 1)
   - n is odd, will need: 2 * (halfPower * halfPower)
   - calls power(2, 0)
   
4. power(2, 0)
   - Base case! Returns 1.0

Call Stack Resolution (Going Up):
4. power(2, 0) → returns 1.0
   
3. power(2, 1) 
   - halfPower = 1.0
   - returns 2 * (1.0 * 1.0) = 2
   
2. power(2, 2)
   - halfPower = 2
   - returns 2 * 2 = 4
   
1. power(2, 5)
   - halfPower = 4
   - returns 2 * (4 * 4) = 2 * 16 = 32

Space Complexity Analysis:
- Each recursive call creates a new stack frame storing:
  * Local variables (x, n, halfPower)
  * Return address
  * Parameters
- Maximum stack depth = O(log n) because:
  * Each recursive call divides n by 2
  * To reach 0 from n, we need log₂(n) divisions
  * Example: 16 → 8 → 4 → 2 → 1 → 0 (depth = log₂(16) = 4)

Time Complexity Analysis:
- Each recursive call: O(1) operations
- Number of recursive calls: O(log n)
- Total time complexity: O(log n)
- We achieve this by:
  * Dividing the problem size by 2 each time (n/2)
  * Reusing the halfPower calculation
  * Avoiding linear recursion (we don't subtract just 1 each time)
```