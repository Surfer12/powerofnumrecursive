calculate the power of a number using recursion and analyze its efficiency.

Objective: This assignment assesses your ability to design and implement a recursive algorithm with a specific time complexity. You will write a function to calculate the power of a number using recursion and analyze its efficiency.

Task:

Write a function power(x, n) that calculates x raised to the power of n, where n is a non-negative integer. Your solution must use recursion. Aim for a time complexity of O(log n).

Requirements:

Functionality: The power(x, n) function should accurately calculate the result for any valid input values of x and n (where n >= 0).
Recursion: The solution must utilize a recursive approach.
Time Complexity: Strive to achieve a time complexity of O(log n).
Explanation: Provide a clear explanation of the time complexity of your code.
Rubric:

Functionality (60%):

Excellent: The function correctly calculates power for all valid inputs. The code is well-structured and easy to understand.
Good: The function calculates power correctly for most inputs but may have minor errors or edge cases not handled correctly.
Fair: The function produces correct results for some inputs but has significant errors or fails to handle many cases.
Needs Improvement: The function does not produce correct results for most inputs.
Time Complexity Analysis (20%):

Excellent: Provides a clear and accurate explanation of time complexity. The explanation is well-supported and demonstrates a strong understanding of how recursion affects time complexity.
Good: The analysis is mostly accurate but may contain minor inaccuracies or lack some depth in explaining the connection between the code and the time complexity.
Fair: The analysis is partially correct but contains significant inaccuracies or lacks a clear connection to the code.
Needs Improvement: The analysis is inaccurate or missing.
Code Optimization (20%):

Excellent: The code is optimized to achieve O(log n) time complexity. The recursive approach effectively reduces the number of computations by dividing the problem in half at each step.
Good: The code demonstrates an attempt at optimization but may not fully achieve O(log n) complexity. There may be areas where the code could be made more efficient.
Fair: The code uses recursion but does not demonstrate any significant optimization techniques. The time complexity is likely higher than O(log n).
Needs Improvement: The code does not use an efficient recursive approach and has a high time complexity